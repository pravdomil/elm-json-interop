module Utils.Json.Decode_ exposing (..)

{-| Generated by <https://github.com/pravdomil/Elm-JSON-Interop>.
-}

import Dict exposing (Dict)
import Json.Decode as D exposing (Decoder)
import Set exposing (Set)


char : Decoder Char
char =
    D.string
        |> D.andThen
            (\a ->
                case a |> String.toList of
                    b :: [] ->
                        D.succeed b

                    _ ->
                        D.fail "I was expecting exactly one character."
            )



--


maybe : Decoder a -> Decoder (Maybe a)
maybe =
    D.nullable


result : Decoder e -> Decoder v -> Decoder (Result e v)
result e v =
    D.field "a" D.int
        |> D.andThen
            (\a___ ->
                case a___ of
                    0 ->
                        D.map Ok (D.field "b" v)

                    1 ->
                        D.map Err (D.field "b" e)

                    _ ->
                        D.fail ("I can't decode Result, unknown variant with index " ++ String.fromInt a___ ++ ".")
            )



--


set : Decoder comparable -> Decoder (Set comparable)
set a =
    D.map Set.fromList (D.list a)


dict : Decoder comparable -> Decoder v -> Decoder (Dict comparable v)
dict k v =
    D.map Dict.fromList (D.list (D.map2 Tuple.pair (D.index 0 k) (D.index 1 v)))



--


unit : Decoder ()
unit =
    D.keyValuePairs D.value
        |> D.andThen
            (\v ->
                case v of
                    [] ->
                        D.succeed ()

                    _ ->
                        D.fail "I can't decode unit type."
            )


tuple : Decoder a -> Decoder b -> Decoder ( a, b )
tuple a b =
    D.map2 Tuple.pair (D.field "a" a) (D.field "b" b)


tuple3 : Decoder a -> Decoder b -> Decoder c -> Decoder ( a, b, c )
tuple3 a b c =
    D.map3 (\a_ b_ c_ -> ( a_, b_, c_ )) (D.field "a" a) (D.field "b" b) (D.field "c" c)


maybeField : String -> Decoder (Maybe a) -> Decoder (Maybe a)
maybeField name a =
    D.oneOf
        [ D.map Just (D.field name D.value)
        , D.succeed Nothing
        ]
        |> D.andThen
            (\v ->
                case v of
                    Just _ ->
                        D.field name a

                    Nothing ->
                        D.succeed Nothing
            )



--


apply : Decoder a -> Decoder (a -> b) -> Decoder b
apply decoder a =
    D.map2 (\fn v -> fn v) a decoder
